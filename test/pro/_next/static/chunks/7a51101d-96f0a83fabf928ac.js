"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[962],{9769:function(n,e,t){t.d(e,{Tt:function(){return f},Vm:function(){return i},kW:function(){return v}});var c=t(3354),o=t(8937),a=t(7176);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let{getBroadcastDims:r}=c.backend_util;function i(n,e,t){let i,T;let m=[];if(n.forEach(n=>{let e=c.util.sizeFromShape(n.shapeInfo.logicalShape);if(n.shapeInfo.isUniform?m.push("uniform float ".concat(n.name).concat(e>1?"[".concat(e,"]"):"",";")):(m.push("uniform sampler2D ".concat(n.name,";")),m.push("uniform int offset".concat(n.name,";"))),t.enableShapeUniforms){let{uniformShape:e}=f(t.packedInputs,n.shapeInfo.logicalShape,n.shapeInfo.texShape);switch(e.length){case 1:m.push("uniform int ".concat(n.name,"Shape;"));break;case 2:m.push("uniform ivec2 ".concat(n.name,"Shape;"));break;case 3:m.push("uniform ivec3 ".concat(n.name,"Shape;"));break;case 4:m.push("uniform ivec4 ".concat(n.name,"Shape;"))}m.push("uniform ivec2 ".concat(n.name,"TexShape;"))}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:m.push("uniform int outShape;");break;case 2:m.push("uniform ivec2 outShape;"),m.push("uniform int outShapeStrides;");break;case 3:m.push("uniform ivec3 outShape;"),m.push("uniform ivec2 outShapeStrides;");break;case 4:m.push("uniform ivec4 outShape;"),m.push("uniform ivec3 outShapeStrides;")}m.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(n=>{m.push("uniform ".concat(n.type," ").concat(n.name).concat(n.arrayIndex?"[".concat(n.arrayIndex,"]"):"",";"))});let R=m.join("\n"),g=n.map(n=>(function(n,e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,i="";t?i+=function n(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(n){let e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),c=(0,o.A)();return"\n    vec4 ".concat(t,"() {\n      return ").concat(c.texture2D,"(").concat(e,", halfCR);\n    }\n  ")}(e);case 1:return function(n,e){let t=n.name,c="get"+t.charAt(0).toUpperCase()+t.slice(1),a=n.shapeInfo.texShape,r=(0,o.A)();if(e)return"\n    vec4 ".concat(c,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(t,"TexShape[0]) / 2.0), ceil(float(").concat(t,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(r.texture2D,"(").concat(t,", uv);\n    }\n  ");let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return"\n    vec4 ".concat(c,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0],", ").concat(i[1],", index);\n      return ").concat(r.texture2D,"(").concat(t,", uv);\n    }\n  ")}(e,t);case 2:return function(n,e){let t=n.shapeInfo.logicalShape,a=n.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=n.shapeInfo.texShape,l=i[0],u=i[1],p=(0,o.A)();if(null!=i&&c.util.arraysEqual(t,i))return e?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(p.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(u,".0, ").concat(l,".0);\n\n        return ").concat(p.texture2D,"(").concat(a,", uv);\n      }\n    ");if(e)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(p.texture2D,"(").concat(a,", uv);\n    }\n  ");let x=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],h=Math.ceil(t[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(h,", ").concat(x[0],", ").concat(x[1],", row, col);\n      return ").concat(p.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){let c=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=e.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===c[0]){let o=S(e,c.slice(1));return"\n        ".concat(n(o,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(C(["b","row","col"],[1,2]),");\n        }\n      ")}let u=(0,o.A)();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(u.texture2D,"(").concat(a,", uv);\n    }\n  ");let p=l[0],x=l[1],h=Math.ceil(c[2]/2),s=h*Math.ceil(c[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(p,", ").concat(x,", ").concat(s,", ").concat(h,", b, row, col);\n      return ").concat(u.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(n,e){let t=n.name,c="get"+t.charAt(0).toUpperCase()+t.slice(1),a=(0,o.A)();if(e)return"\n    vec4 ".concat(c,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(t,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(t,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(t,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(t,"TexShape[0]) / 2.0), ceil(float(").concat(t,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(a.texture2D,"(").concat(t,", uv);\n    }\n  ");let r=n.shapeInfo.logicalShape,i=r.length,l=n.shapeInfo.texShape,u=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],p=u[0],x=u[1],h=Math.ceil(r[i-1]/2),s=h*Math.ceil(r[i-2]/2),d="int b, int row, int col",v="b * ".concat(s," + (row / 2) * ").concat(h," + (col / 2)");for(let n=2;n<i-1;n++)d="int b".concat(n,", ")+d,s*=r[i-n-1],v="b".concat(n," * ").concat(s," + ")+v;return"\n    vec4 ".concat(c,"(").concat(d,") {\n      int index = ").concat(v,";\n      int texR = index / ").concat(x,";\n      int texC = index - texR * ").concat(x,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(x,", ").concat(p,");\n      return ").concat(a.texture2D,"(").concat(t,", uv);\n    }\n  ")}(e,t)}}(n,a):i+=function n(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=e.shapeInfo.logicalShape;switch(o.length){case 0:return function(n,e){let t=n.name,c="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return"float ".concat(c,"() {return ").concat(t,";}");let[o,a]=n.shapeInfo.texShape;if(1===o&&1===a)return"\n      float ".concat(c,"() {\n        return sampleTexture(").concat(t,", halfCR);\n      }\n    ");let r=s(t);if(e)return"\n    float ".concat(c,"() {\n      vec2 uv = uvFromFlat(").concat(t,"TexShape[0], ").concat(t,"TexShape[1], ").concat(r,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  ");let[i,l]=n.shapeInfo.texShape;return"\n    float ".concat(c,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(l,", ").concat(r,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e,t);case 1:return function(n,e){let t=n.name,c="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return"\n      float ".concat(c,"(int index) {\n        ").concat(d(n),"\n      }\n    ");let o=n.shapeInfo.texShape,a=o[0],r=o[1];if(1===r&&1===a)return"\n      float ".concat(c,"(int index) {\n        return sampleTexture(").concat(t,", halfCR);\n      }\n    ");let i=s(t);return 1===r?e?"\n      float ".concat(c,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(t,"TexShape[0]));\n        return sampleTexture(").concat(t,", uv);\n      }\n    "):"\n      float ".concat(c,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(a,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    "):1===a?e?"\n      float ".concat(c,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(t,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(t,", uv);\n      }\n    "):"\n      float ".concat(c,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(r,".0, 0.5);\n        return sampleTexture(").concat(t,", uv);\n      }\n    "):e?"\n    float ".concat(c,"(int index) {\n      vec2 uv = uvFromFlat(").concat(t,"TexShape[0], ").concat(t,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  "):"\n    float ".concat(c,"(int index) {\n      vec2 uv = uvFromFlat(").concat(a,", ").concat(r,", index + ").concat(i,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){let o=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=e.shapeInfo.texShape;if(null!=i&&c.util.arraysEqual(o,i)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");let n=i[0],e=i[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(e,".0, ").concat(n,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}let{newShape:l,keptDims:u}=c.util.squeezeShape(o);if(l.length<o.length){let c=S(e,l);return"\n      ".concat(n(c,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(C(["row","col"],u),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(o[1],", 1)));\n        ").concat(d(e),"\n      }\n    ");let p=i[0],x=i[1],h=s(a);return 1===x?t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(o[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(p,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):1===p?t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(o[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(x,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):t?"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(o[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(p,", ").concat(x,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){let o=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=o[1]*o[2],l=o[2],{newShape:u,keptDims:p}=c.util.squeezeShape(o);if(u.length<o.length){let c=S(e,u);return"\n        ".concat(n(c,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(C(["row","col","depth"],p),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(i,", ").concat(l,", 1)));\n        ").concat(d(e),"\n      }\n    ");let x=e.shapeInfo.texShape,h=x[0],v=x[1],f=e.shapeInfo.flatOffset;if(v===i&&null==f)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(l,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(v,".0, ").concat(h,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(v===l&&null==f)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(o[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(v,".0, ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");let T=s(a);return t?"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(T,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    "):"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(i," + col * ").concat(l," + depth + ").concat(T,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(v,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){let o=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),i=o[3],l=o[2]*i,u=o[1]*l,{newShape:p,keptDims:x}=c.util.squeezeShape(o);if(p.length<o.length){let c=S(e,p);return"\n      ".concat(n(c,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(C(["row","col","depth","depth2"],x),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(u,", ").concat(l,", ").concat(i,", 1)));\n        ").concat(d(e),"\n      }\n    ");let h=e.shapeInfo.flatOffset,v=e.shapeInfo.texShape,f=v[0],T=v[1],m="int stride2 = ".concat(a,"Shape[3];"),R="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(T===u&&null==h)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(m,"\n        ").concat(R,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(l,", ").concat(i,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(T,".0, ").concat(f,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(T===i&&null==h)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(o[1]*o[2],", ").concat(o[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(T,".0, ").concat(f,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");let w=s(a);return t?"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(m,"\n      ").concat(R,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(w,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  "):"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," +\n          depth * ").concat(i," + depth2;\n      vec2 uv = uvFromFlat(").concat(f,", ").concat(T,", index + ").concat(w,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){let t=e.shapeInfo.logicalShape,o=e.name,a="get"+o.charAt(0).toUpperCase()+o.slice(1),r=t[4],i=t[3]*r,l=t[2]*i,u=t[1]*l,{newShape:p,keptDims:x}=c.util.squeezeShape(t);if(p.length<t.length){let t=S(e,p);return"\n      ".concat(n(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(C(["row","col","depth","depth2","depth3"],x),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(i,", ").concat(r,")) +\n          depth3;\n        ").concat(d(e),"\n      }\n    ");let h=e.shapeInfo.flatOffset,v=e.shapeInfo.texShape,f=v[0],T=v[1];if(T===u&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(l,", ").concat(i,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(T,".0, ").concat(f,".0);\n        return sampleTexture(").concat(o,", uv);\n      }\n    ");if(T===r&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(T,".0, ").concat(f,".0);\n        return sampleTexture(").concat(o,", uv);\n      }\n    ");let m=s(o);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(i," +\n          depth2 * ").concat(r," + depth3 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(f,", ").concat(T,", index);\n      return sampleTexture(").concat(o,", uv);\n    }\n  ")}(e);case 6:return function(e){let t=e.shapeInfo.logicalShape,o=e.name,a="get"+o.charAt(0).toUpperCase()+o.slice(1),{newShape:r,keptDims:i}=c.util.squeezeShape(t);if(r.length<t.length){let t=S(e,r);return"\n      ".concat(n(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(C(["row","col","depth","depth2","depth3","depth4"],i),");\n      }\n    ")}let l=t[5],u=t[4]*l,p=t[3]*u,x=t[2]*p,h=t[1]*x;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(h,", ").concat(x,", ").concat(p,", ").concat(u,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(l,", 1)));\n        ").concat(d(e),"\n      }\n    ");let v=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,T=f[0],m=f[1];if(m===h&&null==v)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(x,", ").concat(p,", ").concat(u,", ").concat(l,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(m,".0, ").concat(T,".0);\n        return sampleTexture(").concat(o,", uv);\n      }\n    ");if(m===l&&null==v)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(m,".0, ").concat(T,".0);\n        return sampleTexture(").concat(o,", uv);\n      }\n    ");let R=s(o);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(h," + col * ").concat(x," + depth * ").concat(p," +\n          depth2 * ").concat(u," + depth3 * ").concat(l," + depth4 + ").concat(R,";\n      vec2 uv = uvFromFlat(").concat(T,", ").concat(m,", index);\n      return sampleTexture(").concat(o,", uv);\n    }\n  ")}(e);default:throw Error("".concat(o.length,"-D input sampling")+" is not yet supported")}}(n,a);let l=n.shapeInfo.logicalShape,u=e.logicalShape;return l.length<=u.length&&(t?i+=function(n,e){let t;let o=n.name,a=o.charAt(0).toUpperCase()+o.slice(1),i="get"+a+"AtOutCoords",l=n.shapeInfo.logicalShape.length,u=e.logicalShape.length,p=r(n.shapeInfo.logicalShape,e.logicalShape),x=v(u),h=u-l,s=["x","y","z","w","u","v"];t=0===l?"":u<2&&p.length>=1?"coords = 0;":p.map(n=>"coords.".concat(s[n+h]," = 0;")).join("\n");let d="";d=u<2&&l>0?"coords":n.shapeInfo.logicalShape.map((n,e)=>"coords.".concat(s[e+h])).join(", ");let f="return outputValue;",S=1===c.util.sizeFromShape(n.shapeInfo.logicalShape),C=1===c.util.sizeFromShape(e.logicalShape);if(1!==l||S||C){if(S&&!C)f=1===u?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(p.length){let n=l-2,e=l-1;p.indexOf(n)>-1&&p.indexOf(e)>-1?f="return vec4(outputValue.x);":p.indexOf(n)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":p.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(i,"() {\n      ").concat(x," coords = getOutputCoords();\n      ").concat(t,"\n      vec4 outputValue = get").concat(a,"(").concat(d,");\n      ").concat(f,"\n    }\n  ")}(n,e):i+=function(n,e){let t;let o=n.name,a=o.charAt(0).toUpperCase()+o.slice(1),i="get"+a+"AtOutCoords",l=e.texShape,u=n.shapeInfo.texShape,p=n.shapeInfo.logicalShape.length,x=e.logicalShape.length;if(!n.shapeInfo.isUniform&&p===x&&null==n.shapeInfo.flatOffset&&c.util.arraysEqual(u,l))return"\n      float ".concat(i,"() {\n        return sampleTexture(").concat(o,", resultUV);\n      }\n    ");let h=v(x),s=r(n.shapeInfo.logicalShape,e.logicalShape),d=x-p,f=["x","y","z","w","u","v"];t=0===p?"":x<2&&s.length>=1?"coords = 0;":s.map(n=>"coords.".concat(f[n+d]," = 0;")).join("\n");let S="";return S=x<2&&p>0?"coords":n.shapeInfo.logicalShape.map((n,e)=>"coords.".concat(f[e+d])).join(", "),"\n    float ".concat(i,"() {\n      ").concat(h," coords = getOutputCoords();\n      ").concat(t,"\n      return get").concat(a,"(").concat(S,");\n    }\n  ")}(n,e)),i})(n,e,t.packedInputs,t.enableShapeUniforms)).join("\n"),w=e.texShape,y=(0,o.A)(),I="\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(y.texture2D,"(textureSampler, uv).r;\n    }\n  "),U="".concat(y.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(y.varyingFs," vec2 resultUV;\n    ").concat(y.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(y.defineSpecialNaN,"\n    ").concat(y.defineSpecialInf,"\n    ").concat(y.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(l,"\n    ").concat(u,"\n    ").concat(p,"\n  ");return e.isPacked?(i=function(n,e,t){switch(n.length){case 0:return h();case 1:return function(n,e,t){let c=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===c[0]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(c[1],".0);\n      }\n    "):1===c[1]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(c[0],".0);\n      }\n    "):t?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(c[0],", ").concat(c[1],"));\n      return 2 * (resTexRC.x * ").concat(c[1]," + resTexRC.y);\n    }\n  ")}(0,e,t);case 2:return function(n,e,t){let o=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(c.util.arraysEqual(n,e))return t?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(o[0],", ").concat(o[1],"));\n      }\n    ");let a=Math.ceil(n[1]/2);return t?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(o[0],", ").concat(o[1],"));\n\n      int index = resTexRC.x * ").concat(o[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(n,e,t);case 3:return function(n,e,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let c=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(n[2]/2),a=o*Math.ceil(n[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(c[0],", ").concat(c[1],"));\n      int index = resTexRC.x * ").concat(c[1]," + resTexRC.y;\n\n      int b = index / ").concat(a,";\n      index -= b * ").concat(a,";\n\n      int r = 2 * (index / ").concat(o,");\n      int c = imod(index, ").concat(o,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(n,e,t);default:return function(n,e,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let c=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(n[n.length-1]/2),a=o*Math.ceil(n[n.length-2]/2),r=a,i="",l="b, r, c";for(let e=2;e<n.length-1;e++)r*=n[n.length-e-1],i="\n      int b".concat(e," = index / ").concat(r,";\n      index -= b").concat(e," * ").concat(r,";\n    ")+i,l="b".concat(e,", ")+l;return"\n    ivec".concat(n.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(c[0],", ").concat(c[1],"));\n      int index = resTexRC.x * ").concat(c[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(a,";\n      index -= b * ").concat(a,";\n\n      int r = 2 * (index / ").concat(o,");\n      int c = imod(index, ").concat(o,") * 2;\n\n      return ivec").concat(n.length,"(").concat(l,");\n    }\n  ")}(n,e,t)}}(e.logicalShape,w,t.enableShapeUniforms),T="\n    void setOutput(vec4 val) {\n      ".concat(y.output," = val;\n    }\n  ")):(i=function(n,e,t){switch(n.length){case 0:return h();case 1:return 1===e[0]?t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(e[1],".0);\n      }\n    "):1===e[1]?t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(e[0],".0);\n      }\n    "):t?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      return resTexRC.x * ").concat(e[1]," + resTexRC.y;\n    }\n  ");case 2:return c.util.arraysEqual(n,e)?t?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(e[0],", ").concat(e[1],"));\n      }\n    "):1===n[1]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(e[0],", ").concat(e[1],"));\n        int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "):1===n[0]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(e[0],", ").concat(e[1],"));\n        int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    "):t?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      int r = index / ").concat(n[1],";\n      int c = index - r * ").concat(n[1],";\n      return ivec2(r, c);\n    }\n  ");case 3:return function(n,e,t){if(t){let e=a.Kn(["r","c","d"],n);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(e,"\n    return ivec3(r, c, d);\n  }\n")}let c=a.RW(["r","c","d"],n);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      ").concat(c,"\n      return ivec3(r, c, d);\n    }\n  ")}(n,e,t);case 4:return function(n,e,t){if(t){let e=a.Kn(["r","c","d","d2"],n);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(e,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}let c=a.RW(["r","c","d","d2"],n);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n      ").concat(c,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(n,e,t);case 5:return function(n,e){let t=a.RW(["r","c","d","d2","d3"],n);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(e[0],",\n                             ").concat(e[1],"));\n\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n\n      ").concat(t,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(n,e);case 6:return function(n,e){let t=a.RW(["r","c","d","d2","d3","d4"],n);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(e[0],", ").concat(e[1],"));\n      int index = resTexRC.x * ").concat(e[1]," + resTexRC.y;\n\n      ").concat(t,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(n,e);default:throw Error("".concat(n.length,"-D output sampling is not yet supported"))}}(e.logicalShape,w,t.enableShapeUniforms),T="\n    void setOutput(float val) {\n      ".concat(y.output," = vec4(val, 0, 0, 0);\n    }\n  ")),t.packedInputs&&(U+=x),[U,I,T,R,i,g,t.userCode].join("\n")}let l="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",u="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",p="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",x="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function h(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function s(n){return"offset".concat(n)}function d(n){let e=n.name,t=c.util.sizeFromShape(n.shapeInfo.logicalShape);return t<2?"return ".concat(e,";"):"\n    for (int i = 0; i < ".concat(t,"; i++) {\n      if (i == index) {\n        return ").concat(e,"[i];\n      }\n    }\n  ")}function v(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error("GPU for rank ".concat(n," is not yet supported"))}function f(n,e,t){let{newShape:o,keptDims:a}=c.util.squeezeShape(e),r=e.length,i=n&&3===r&&1===e[0],l=i?e.slice(1):o,u=!n&&r>1&&!c.util.arraysEqual(e,t)&&o.length<r||i,p=u?l:e;return{useSqueezeShape:u,uniformShape:p,keptDims:a}}function S(n,e){let t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function C(n,e){return e.map(e=>n[e]).join(", ")}}}]);